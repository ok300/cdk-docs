{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Intro","text":"<p>The Cashu Development Kit (CDK) is a Rust toolkit for the development of Cashu wallets and mints.</p>"},{"location":"#for-wallet-developers","title":"For wallet developers","text":"<p>It implements the Cashu protocol and exposes its operations through a simple interface, making it easy for app developers to integrate a Cashu wallet with just a few lines of code.</p> <p>To get started, go to the CDK Wallet Intro</p>"},{"location":"#for-mint-operators","title":"For mint operators","text":"<p>CDK provides a full mint implementation, with guides on how to configure, run and maintain it.</p> <p>To get started, go to the CDK Mint Intro</p>"},{"location":"mint/00_intro/","title":"Intro","text":"<p>The CDK mint is a full Cashu mint implementation.</p> <p>The following guides will show you how to get the CDK Mint up and running</p> <ul> <li>using LND or</li> <li>using CLN</li> </ul>"},{"location":"mint/01_container_with_lnd/","title":"Run as container with LND","text":"<p>Environment</p> <p>This guide assumes a headless Fedora Server 41 machine. The exact commands may be different for your setup.</p> <p>These instructions were last tested with <code>cdk-mintd v0.8.1</code>.</p> <p>Prerequisites</p> <ul> <li>LND is reachable from the machine where you are installing the mint</li> </ul> <p>Create a working directory that will be used by <code>cdk-mintd</code>:</p> <pre><code>mkdir ~/.cdk-mintd\ncd ~/.cdk-mintd\n</code></pre> <p>Copy the following two files from your LND node into this working directory:</p> <ul> <li><code>tls.cert</code>: typically found under <code>&lt;lnd-data-dir&gt;/tls.cert</code></li> <li><code>admin.macaroon</code>: typically found under <code>&lt;lnd-data-dir&gt;/data/chain/bitcoin/&lt;network&gt;/admin.macaroon</code></li> </ul> <p>Download the sample CDK mint configuration file and save it as <code>config.toml</code>:</p> <pre><code>curl -o config.toml https://raw.githubusercontent.com/cashubtc/cdk/refs/tags/v0.8.1/crates/cdk-mintd/example.config.toml\n</code></pre> <p>Note the <code>v0.8.1</code> release version in the URL. Change it according to the version you're using.</p> <p>Edit the downloaded <code>config.toml</code> as follows:</p> <ul> <li>change <code>info.url</code> to the URL under which your mint will be accessible</li> <li>change <code>info.listen_host</code> to <code>0.0.0.0</code></li> <li>change <code>info.mnemonic</code> to a new mnemonic</li> <li>edit the fields in <code>mint_info</code> with public details of your mint (name, description, etc)</li> <li>change <code>ln.ln_backend</code> to <code>lnd</code></li> <li>un-comment the entire <code>lnd</code> section</li> <li>change <code>lnd.address</code> to <code>https://ip:port</code> with the IP and port where your LND node exposes its gRPC interface</li> <li>change <code>lnd.macaroon_file</code> to <code>/root/.cdk-mintd/admin.macaroon</code></li> <li>change <code>lnd.cert_file</code> to <code>/root/.cdk-mintd/tls.cert</code></li> </ul> <p>Your mint working directory should now contain:</p> <pre><code>ls ~/.cdk-mintd\nconfig.toml  admin.macaroon  tls.cert\n</code></pre> <p>Create and run a <code>cdk-mintd</code> container that also:</p> <ul> <li>mounts your local mint working directory, so it's available from within the container</li> <li>binds port <code>8085</code> (the <code>info.listen_port</code> defined in <code>config.toml</code>), so that it's reachable from outside the container, but only on your host's loopback interface</li> </ul> <pre><code>podman run -d --name cdk-mintd \\\n    -p 127.0.0.1:8085:8085 \\\n    -v ~/.cdk-mintd:/root/.cdk-mintd:Z \\\n    docker.io/thesimplekid/cdk-mintd:latest\n</code></pre> <p>With the container running, check that the mint service is reachable from your host:</p> <pre><code>curl http://localhost:8085/v1/info\n# JSON output\n</code></pre> <p>After you confirmed it's working, stop the container:</p> <pre><code>podman stop cdk-mintd\n</code></pre> <p>The next step is to create a system service.</p>"},{"location":"mint/02_container_with_cln/","title":"Run as container with CLN","text":"<p>Environment</p> <p>This guide assumes a headless Fedora Server 41 machine. The exact commands may be different for your setup.</p> <p>These instructions were last tested with <code>cdk-mintd v0.8.1</code>.</p> <p>Prerequisites</p> <ul> <li>CLN is running on the same machine as the one where you're setting up the mint</li> </ul> <p>Create a working directory that will be used by <code>cdk-mintd</code>:</p> <pre><code>mkdir ~/.cdk-mintd\ncd ~/.cdk-mintd\n</code></pre> <p>Download the sample CDK mint configuration file and save it as <code>config.toml</code>:</p> <pre><code>curl -o config.toml https://raw.githubusercontent.com/cashubtc/cdk/refs/tags/v0.8.1/crates/cdk-mintd/example.config.toml\n</code></pre> <p>Note the <code>v0.8.1</code> release version in the URL. Change it according to the version you're using.</p> <p>Edit the downloaded <code>config.toml</code> as follows:</p> <ul> <li>change <code>info.url</code> to the URL under which your mint will be accessible</li> <li>change <code>info.listen_host</code> to <code>0.0.0.0</code></li> <li>change <code>info.mnemonic</code> to a new mnemonic</li> <li>edit the fields in <code>mint_info</code> with public details of your mint (name, description, etc)</li> <li>change <code>ln.ln_backend</code> to <code>cln</code></li> <li>un-comment the entire <code>cln</code> section</li> <li>change <code>cln.rpc_path</code> to <code>/root/.lightningd/lightning-rpc</code></li> </ul> <p>Your mint working directory should now contain:</p> <pre><code>ls ~/.cdk-mintd\nconfig.toml\n</code></pre> <p>Create and run a <code>cdk-mintd</code> container that also:</p> <ul> <li>mounts your local mint working directory, so it's available from within the container</li> <li>makes the local CLN RPC socket file available inside the container at <code>/root/.lightningd/lightning-rpc</code></li> <li>binds port <code>8085</code> (the <code>info.listen_port</code> defined in <code>config.toml</code>), so that it's reachable from outside the container, but only on your host's loopback interface</li> </ul> <pre><code>podman run -d --name cdk-mintd \\\n    -p 127.0.0.1:8085:8085 \\\n    -v ~/.cdk-mintd:/root/.cdk-mintd:Z \\\n    -v &lt;path-to-lightning-rpc&gt;:/root/.lightningd/lightning-rpc:Z \\\n    docker.io/thesimplekid/cdk-mintd:latest\n</code></pre> <p>Path to <code>lightning-rpc</code></p> <p>Before running the command, replace <code>&lt;path-to-lightning-rpc&gt;</code> with the path to your CLN installation's <code>lightning-rpc</code> Unix domain socket, which is typically found at <code>~/.lightning/&lt;network&gt;/lightning-rpc</code>.</p> <p>With the container running, check that the mint service is reachable from your host:</p> <pre><code>curl http://localhost:8085/v1/info\n# JSON output\n</code></pre> <p>After you confirmed it's working, stop the container:</p> <pre><code>podman stop cdk-mintd\n</code></pre> <p>The next step is to create a system service.</p>"},{"location":"mint/03_systemd_service/","title":"Create <code>systemd</code> Service","text":"<p>This section assumes you already have a container called <code>cdk-mintd</code>.</p> <p>It will show how to create a system service from the existing container. This will allow the container to be automatically started when the host starts up.</p> <p>To create a system service:</p> <pre><code>cd ~\n\n# Create a service file\npodman generate systemd --name cdk-mintd --files --new\n\n# Copy the service file to the systemd directory\nsudo cp container-cdk-mintd.service /etc/systemd/system/\n\n# Enable and start the service\nsudo systemctl daemon-reload\nsudo systemctl enable container-cdk-mintd.service\nsudo systemctl start container-cdk-mintd.service\n</code></pre> <p>With the new <code>container-cdk-mintd</code> service running, check that the mint is reachable from your host:</p> <pre><code>curl http://localhost:8085/v1/info\n# JSON output\n</code></pre> <p>The next and final step is to expose the mint service through a reverse proxy.</p>"},{"location":"mint/04_reverse_proxy/","title":"Setup Reverse Proxy","text":"<p>The mint service created in the previous section listens only on the loopback interface, meaning it is not reachable from outside.</p> <p>This section will go over how to expose the mint service to the internet, by using a reverse proxy. In this example we'll use <code>caddy</code>.</p> <p>This assumes you are installing the mint on a machine that is directly reachable from the internet using a domain or subdomain.</p> <p>Edit the default <code>Caddyfile</code> at <code>/etc/caddy/Caddyfile</code> as follows:</p> <ul> <li>un-comment the <code>reverse-proxy</code> line and change it to <code>reverse-proxy localhost:8085</code></li> <li>comment out the <code>file-server</code> line</li> </ul> <p>Then restart <code>caddy</code>:</p> <pre><code>sudo systemctl restart caddy\n</code></pre> <p>Your mint should now be publicly accessible.</p> <p>Once you've tested the mint is publicly reachable over HTTP, you can switch to HTTPS by editing the <code>Caddyfile</code> and replacing <code>http://</code> in the first un-commented line with <code>your-mint-domain.com</code>. Re-start <code>caddy</code> to generate and apply an HTTPS certificate.</p>"},{"location":"wallet/00_intro/","title":"Intro","text":"<p>The CDK library helps applications integrate a Cashu wallet.</p> <p>The <code>cdk-cli</code> is an example app built with the CDK. You may want to give it a try to get familiar with the main concepts.</p> <p>Once you're ready to integrate a cashu wallet into your application, you can get started.</p>"},{"location":"wallet/01_get_started/","title":"Get Started","text":""},{"location":"wallet/01_get_started/#setup-project","title":"Setup Project","text":"<p>CDK supports several storage backends:</p> <ul> <li><code>cdk-redb</code> for Redb</li> <li><code>cdk-rexie</code> for Rexie</li> <li><code>cdk-sqlite</code> for SQLite</li> </ul> <p>Add the dependencies for CDK and the chosen storage backend to your <code>Cargo.toml</code>:</p> <pre><code>#cdk = { version = \"0.8.1\", features = [\"wallet\"] }\n#cdk-sqlite = { version = \"0.8.1\", features = [\"wallet\"] }\n\ncdk = { git = \"https://github.com/ok300/cdk\", branch = \"ok300-add-expect-wallet\", features = [\"wallet\"] }\ncdk-sqlite = { git = \"https://github.com/ok300/cdk\", branch = \"ok300-add-expect-wallet\", features = [\"wallet\"] }\n</code></pre>"},{"location":"wallet/01_get_started/#initialize-cdk-wallet","title":"Initialize CDK Wallet","text":"<p>Based on the chosen DB type, initialize the DB location and the CDK wallet:</p> <pre><code>async fn init_wallet() -&gt; Result&lt;Arc&lt;MultiMintWallet&gt;&gt; {\n    let work_dir = std::env::current_dir()?;\n    let sql_path = work_dir.join(\"cdk-db.sqlite\");\n    let localstore = Arc::new(WalletSqliteDatabase::new(&amp;sql_path).await?);\n    let seed = Arc::new(Mnemonic::generate(12)?.to_seed_normalized(\"\"));\n\n    let multi_mint_wallet = MultiMintWallet::new(localstore.clone(), seed, vec![]);\n    for (mint_url, _) in localstore.get_mints().await? {\n        multi_mint_wallet\n            .create_and_add_wallet(&amp;mint_url.to_string(), CurrencyUnit::Sat, None)\n            .await?;\n    }\n\n    Ok(Arc::new(multi_mint_wallet))\n}\n</code></pre>"},{"location":"wallet/02_appendix_cli/","title":"CLI","text":"<p>The <code>cdk-cli</code> crate contains a simple wallet implementation.</p> <p>It is not necessary for wallet development, but it can be a useful interactive exercise to get familiar with the main Cashu concepts and operations.</p>"},{"location":"wallet/02_appendix_cli/#setup","title":"Setup","text":"<p>Install it with:</p> <pre><code>cargo install cdk-cli\n</code></pre>"},{"location":"wallet/02_appendix_cli/#mint","title":"Mint","text":"<p>Minting is the operation by which cashu tokens are brought into existence (minted), typically by sending an equivalent amount of sats to the mint. See NUT-04.</p> <p>Mint 10 test sats on a test mint with:</p> <pre><code>cdk-cli mint https://testnut.cashu.space 10\n</code></pre> <p>This creates a mint request for 10 sats and simulates the payment of a matching BOLT11 invoice. Since this is a test mint, these are only test sats for demonstration purposes. On a real mint, <code>melt</code> is the operation by which a user can convert real sats into ecash.</p> <p>The end result is the CLI wallet should have the 10 sats as ecash, which can be seen by checking the balance:</p> <pre><code>cdk-cli balance\n</code></pre>"},{"location":"wallet/02_appendix_cli/#send-ecash","title":"Send ecash","text":"<p>Use</p> <pre><code>cdk-cli send\n</code></pre> <p>to send the 10 sats of ecash. A cashu token will be printed similar to</p> <pre><code>cashuBo2FteBtodHRwczovL3Rlc3RudXQuY2FzaHUuc3BhY2VhdWNzYXRhdIGiYWlIAJofKTJT5B5hcIKkYWEIYXN4QGIzNDRjZGViMDY0YjNiMWZjN2I2YzI5YzNmNDg1MTBlZWFkODIyMzMzZmQ2ZTBlZTY4ZmFhNjVmYTM3NzgzZDhhY1ghAgEhIRRixGTV5aA4C9w5z--YIUa8OQ53-NWODcC3IMIPYWT2pGFhAmFzeEA2MzgyODE4NmQ3YjRiOTI0YmEyMmNlMGIyYWQ4MGZlY2ZkZTc2N2I2ZDlmNWQ0NDQzNzkxMjRjZmE0YmI5Nzc1YWNYIQIjJX-SeR6Ct5dp5mYP9INA62BbhQhKVP5Mjn05qNxjFmFk9g==\n</code></pre> <p>Checking the balance after <code>send</code> will show a reduced balance.</p> <p>The ecash can be sent by simply sending this ecash token to the recipient via any communications medium (QR code, email, etc).</p> <p>The ecash token itself contains all the information necessary for a cashu wallet to claim the corresponding sats from that mint.</p> <p>To dig deeper and see the actual contents of the token, use</p> <pre><code>cdk-cli decode-token cashuB...\n</code></pre> <p>and read NUT-00 for the meaning of each field.</p>"},{"location":"wallet/02_appendix_cli/#receive-ecash","title":"Receive ecash","text":"<p>Any wallet (including the sender) can receive the token:</p> <pre><code>cdk-cli receive cashuB...\n</code></pre> <p>which will then reflect in the wallet's balance.</p>"},{"location":"wallet/02_appendix_cli/#melt","title":"Melt","text":"<p>Melting is the reverse of minting. It's the operation by which Cashu tokens can be redeemed for the artefact they represent, typically a sat amount. See NUT-05.</p> <p>A wallet that holds an ecash balance can melt ecash with</p> <pre><code>cdk-cli melt\n</code></pre> <p>Since this example used fake sats from a test mint, the BOLT11 invoice will not be paid by the mint. However, when using a real mint, <code>melt</code> would allow the receiver to convert the ecash back into sats.</p>"},{"location":"wallet/core/00_intro/","title":"Core Operations","text":"<p>This section goes over the core wallet operations. These are based on the mandatory parts of the protocol spec, more specifically NUT-01 to NUT-06.</p>"},{"location":"wallet/core/01_add_mints/","title":"Add Mints","text":"<p>Trust model</p> <p>Adding a mint to the CDK <code>MultiMintWallet</code> implies the user trusts this mint enough to hold a cashu balance on it. Adding a mint should therefore need explicit user confirmation in the UI.</p> <pre><code>async fn add_mint(multi_mint_wallet: &amp;MultiMintWallet, mint_url_str: &amp;str) -&gt; Result&lt;()&gt; {\n    let mint_url = MintUrl::from_str(mint_url_str)?;\n    let client = HttpClient::new(mint_url.clone(), None);\n\n    let mint_info = client.get_mint_info().await?;\n    multi_mint_wallet\n        .localstore\n        .add_mint(mint_url.clone(), Some(mint_info))\n        .await?;\n\n    // TODO Show mint info to user, get confirmation\n\n    let keys = client.get_mint_keys().await?;\n    let units: Vec&lt;CurrencyUnit&gt; = keys.into_iter().map(|ks| ks.unit).collect();\n    for unit in units {\n        let wallet_key = WalletKey::new(mint_url.clone(), unit.clone());\n\n        if !multi_mint_wallet.has(&amp;wallet_key).await {\n            multi_mint_wallet\n                .create_and_add_wallet(mint_url_str, unit, None)\n                .await?;\n        }\n    }\n\n    Ok(())\n}\n</code></pre> <p>The <code>MintInfo</code> is described in NUT-06. </p>"},{"location":"wallet/core/02_get_balances/","title":"Get Balances","text":"<p>There is a separate balance for each mint and each unit:</p> <pre><code>pub async fn mint_balances(multi_mint_wallet: &amp;MultiMintWallet) -&gt; Result&lt;(), Error&gt; {\n    for wallet in multi_mint_wallet.get_wallets().await {\n        let balance = wallet.total_balance().await?;\n        let unit = wallet.unit;\n        let mint_url = wallet.mint_url;\n\n        println!(\"{mint_url}: {balance} {unit}\");\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"wallet/core/03_receive_payments/","title":"Receive payments","text":"<p>Receiving ecash tokens can be done in a few ways:</p> <ul> <li>receiving ecash directly</li> <li>minting ecash tokens</li> </ul>"},{"location":"wallet/core/03_receive_payments/#receive-ecash","title":"Receive ecash","text":"<p>In this case, the sender sends ecash and we receive ecash:</p> <pre><code>async fn receive_token(\n    multi_mint_wallet: &amp;MultiMintWallet,\n    token_str: &amp;str,\n    signing_keys: &amp;[SecretKey],\n    preimage: &amp;[String],\n) -&gt; Result&lt;Amount, anyhow::Error&gt; {\n    let token: Token = Token::from_str(token_str)?;\n\n    let mint_url = token.mint_url()?;\n    let unit = token.unit().unwrap_or_default();\n    let wallet_key = WalletKey::new(mint_url.clone(), unit.clone());\n\n    if !multi_mint_wallet.has(&amp;wallet_key).await {\n        multi_mint_wallet\n            .create_and_add_wallet(&amp;mint_url.to_string(), unit, None)\n            .await?;\n    }\n\n    let amount = multi_mint_wallet\n        .receive(token_str, signing_keys, preimage)\n        .await?;\n    Ok(amount)\n}\n</code></pre>"},{"location":"wallet/core/03_receive_payments/#receive-from-lightning","title":"Receive from Lightning","text":"<p>In this situation, the sender sends Lightning sats, for which the mint creates ecash, and we receive the ecash.</p> <p>This is sometimes also referred to as \"minting ecash\".</p> <pre><code>pub async fn mint(\n    multi_mint_wallet: &amp;MultiMintWallet,\n    mint_url: MintUrl,\n    amount: Amount,\n    unit: CurrencyUnit,\n    description: Option&lt;String&gt;,\n) -&gt; Result&lt;()&gt; {\n    let wallet_key = WalletKey::new(mint_url.clone(), unit.clone());\n    let wallet = match multi_mint_wallet.get_wallet(&amp;wallet_key).await {\n        Some(wallet) =&gt; wallet.clone(),\n        None =&gt; {\n            multi_mint_wallet\n                .create_and_add_wallet(&amp;mint_url.to_string(), unit.clone(), None)\n                .await?\n        }\n    };\n\n    let quote = wallet.mint_quote(amount, description).await?;\n\n    println!(\"Quote: {:#?}\", quote);\n\n    println!(\"Please pay: {}\", quote.request);\n\n    let mut subscription = wallet\n        .subscribe(WalletSubscription::Bolt11MintQuoteState(vec![quote\n            .id\n            .clone()]))\n        .await;\n\n    while let Some(msg) = subscription.recv().await {\n        if let NotificationPayload::MintQuoteBolt11Response(response) = msg {\n            if response.state == MintQuoteState::Paid {\n                break;\n            }\n        }\n    }\n\n    let receive_proofs = wallet.mint(&amp;quote.id, SplitTarget::default(), None).await?;\n    let receive_amount = receive_proofs.total_amount()?;\n\n    println!(\"Received {receive_amount} from mint {mint_url}\");\n\n    Ok(())\n}\n</code></pre>"},{"location":"wallet/core/04_send_payments/","title":"Send payments","text":"<p>Automatic swap</p> <p>Sending will automatically <code>swap</code> (see NUT-03) tokens if necessary, to ensure the correct amount is sent.</p>"},{"location":"wallet/core/04_send_payments/#send-ecash","title":"Send ecash","text":"<pre><code>pub async fn send(\n    multi_mint_wallet: &amp;MultiMintWallet,\n    mint_url: MintUrl,\n    send_amount: Amount,\n    send_unit: CurrencyUnit,\n) -&gt; Result&lt;Token&gt; {\n    let wallet_key = WalletKey::new(mint_url, send_unit.clone());\n    let wallet = multi_mint_wallet.expect_wallet(&amp;wallet_key).await?;\n\n    let prepared_send = wallet\n        .prepare_send(\n            send_amount,\n            SendOptions {\n                include_fee: true,\n                ..Default::default()\n            },\n        )\n        .await?;\n    println!(\"The fees are: {} {send_unit}\", prepared_send.fee());\n\n    let token = wallet.send(prepared_send, None).await?;\n    println!(\"The token is: {token}\");\n\n    Ok(token)\n}\n</code></pre>"},{"location":"wallet/core/04_send_payments/#send-to-lightning","title":"Send to Lightning","text":"<p>In this situation, the sender converts ecash into Lightning sats and pays the receiver's Lightning invoice in one step.</p> <p>This is sometimes also referred to as \"melting ecash\".</p> <pre><code>pub async fn melt(\n    multi_mint_wallet: &amp;MultiMintWallet,\n    mint_url: MintUrl,\n    send_unit: CurrencyUnit,\n    bolt11: String,\n) -&gt; Result&lt;Melted&gt; {\n    let wallet_key = WalletKey::new(mint_url, send_unit);\n    let wallet = multi_mint_wallet.expect_wallet(&amp;wallet_key).await?;\n\n    let quote = wallet.melt_quote(bolt11, None).await?;\n    let melt = wallet.melt(&amp;quote.id).await?;\n\n    Ok(melt)\n}\n</code></pre>"}]}